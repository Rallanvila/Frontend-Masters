# Javascript: The Hard Parts, v2

## Javascript Principles

### Definitions Learned

**Execution context** - created to run the code of a function - has two parts (we've already seen them!)

- thread of execution
- memory

**Call Stack**- the process on how JS runs code

- Javascript keeps track of what function is currently running (where's the thread of execution)
- Run a fn - add to call stack
- Finish running hte function - JS removes it from call stack
- Whatever is top of the call stack -that's the fn we're currently running

**Higher Order Fns** - the outer fn that takes in a fn in our higher order fn
**Callback Fn** - the function we insert is our callback function.

## Functions and Callbacks

- Fn help with keeping your code dry (don't repeat yourself)

```javascript
function tonSquared() {
  return 10 * 10;
}

function nineSquared() {
  return 9 * 9;
}
```

the above is a bad practice as it's not dry, you can accomplish the same with the below and it'll be reusable and stored in the memory one time.

```javascript
function squareNum(number) {
  return num * num;
}
```

### Closure

- Closure is the most esoteric of Javascript concepts
- Enables powerful pro-level functions like 'once' and 'memoize'
- Many JS design patters including the module pattern use closure
- build iterators, handle partial application and maintain state in an asynchronous wold.

#### Functions with memories

- when our functions get called, we create a live store of data (local memory/variable environment/state) for that function's execution context
- when the function finishes executing, it's local memory is deleted (except the returned value)
- This owuld let our function definitions have an associated cache/persistant memory
- But it all starts with us **returning a function from another function**

```javascript 
function createFunction() {
  function multiplyBy2(num) {
    return num * 2;
  }
  return multiplyBy2;
}

const generatedFunc = createFunction();
const result = generatedFun(3);
```

what's happening above:

1. `createFunction` is being declared and being stored in the global memory and is returning the `fn` `multiplyBy2`
2. `generateFunction` is being declared and since `createFunction()` is returning `multiplyBy2`, that is what `generateFunction` is. **it becomes the function it is returning and that is all. There is no corelation to the name declared whatsoever because it has left the execution context**
3. `result` is executing `generateFunction` with 3, in essence doing `multiplyBy2(3)`. This starts a new execution context.

### Backpack - (Persistent Lexical Static Scope Linked Data):
Below in the backpack concept, `outer()` is returning the function `incrementCounter()`. `myNewFunciton` has  now become `incrementCounter`, 

Now this is the cool part, what's being illustrated in the drawing is where it's looking for the `counter` variable in order to increment it. When it's stored inside a function like this, it has a `backpack` that carries it's individual scope, to keep everything separate. 

![image](./images/backpack-concept.png)

#### What can we call this 'backpack'?
* Closed over 'Variable Environment' (C.O.V.E)
* Persistent Lexical Scope Referenced Data (P.L.S.R.D)
* 'Backpack'
* 'Closure'

The 'backpack' (or 'closure') of live data is attached `incrementCounter` (then to `MyNewFunction`) though a hidden party known as [(scope)] which persists when the inner function is returned out.

*Below illustrates how the above can create powerful spots in memory that have it's own localized memory. I believe this is how frameworks like React are built upon. Essentially, each component is able to exist with it's own state, due to closure*

![image](./images/backpack2.png)
