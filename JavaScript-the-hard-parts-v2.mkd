# Javascript: The Hard Parts, v2

## Javascript Principles

### Definitions Learned

**Execution context** - created to run the code of a function - has two parts (we've already seen them!)

- thread of execution
- memory

**Call Stack**- the process on how JS runs code

- Javascript keeps track of what function is currently running (where's the thread of execution)
- Run a fn - add to call stack
- Finish running hte function - JS removes it from call stack
- Whatever is top of the call stack -that's the fn we're currently running

**Higher Order Fns** - the outer fn that takes in a fn in our higher order fn
**Callback Fn** - the function we insert is our callback function.

## Functions and Callbacks

- Fn help with keeping your code dry (don't repeat yourself)

```javascript
function tonSquared() {
  return 10 * 10;
}

function nineSquared() {
  return 9 * 9;
}
```

the above is a bad practice as it's not dry, you can accomplish the same with the below and it'll be reusable and stored in the memory one time.

```javascript
function squareNum(number) {
  return num * num;
}
```

### Closure

- Closure is the most esoteric of Javascript concepts
- Enables powerful pro-level functions like 'once' and 'memoize'
- Many JS design patters including the module pattern use closure
- build iterators, handle partial application and maintain state in an asynchronous wold.

#### Functions with memories

- when our functions get called, we create a live store of data (local memory/variable environment/state) for that function's execution context
- when the function finishes executing, it's local memory is deleted (except the returned value)
- This owuld let our function definitions have an associated cache/persistant memory
- But it all starts with us **returning a function from another function**

```javascript
function createFunction() {
  function multiplyBy2(num) {
    return num * 2;
  }
  return multiplyBy2;
}

const generatedFunc = createFunction();
const result = generatedFun(3);
```

what's happening above:

1. `createFunction` is being declared and being stored in the global memory and is returning the `fn` `multiplyBy2`
2. `generateFunction` is being declared and since `createFunction()` is returning `multiplyBy2`, that is what `generateFunction` is. **it becomes the function it is returning and that is all. There is no corelation to the name declared whatsoever because it has left the execution context**
3. `result` is executing `generateFunction` with 3, in essence doing `multiplyBy2(3)`. This starts a new execution context.
